{
  lib,
  config,
  ...
}:
with lib; let
  cfg = config.services.declarative-jellyfin;

  # Default type options generated by jellyfin
  defaultTypeOptions = {
    movies = {
      Movie = {
        metadataFetchers = [
          "TheMovieDb"
          "The Open Movie Database"
        ];
        imageFetchers = [
          "TheMovieDb"
          "The Open Movie Database"
          "Embedded Image Extractor"
          "Screen Grabber"
        ];
      };
    };
    tvshows = {
      Series = {
        metadataFetchers = [
          "TheMovieDb"
          "The Open Movie Database"
        ];
        imageFetchers = ["TheMovieDb"];
      };
      Season = {
        metadataFetchers = ["TheMovieDb"];
        imageFetchers = ["TheMovieDb"];
      };
      Episode = {
        metadataFetchers = [
          "TheMovieDb"
          "The Open Movie Database"
        ];
        imageFetchers = [
          "TheMovieDb"
          "The Open Movie Database"
          "Embedded Image Extractor"
          "Screen Grabber"
        ];
      };
    };
    music = {
      MusicArtist = {
        metadataFetchers = ["MusicBrainz"];
        imageFetchers = ["TheAudioDB"];
      };
      MusicAlbum = {
        metadataFetchers = ["MusicBrainz"];
        imageFetchers = ["TheAudioDB"];
      };
      Audio = {
        metadataFetchers = [];
        imageFetchers = ["Image Extractor"];
      };
      MusicVideo = {
        metadataFetchers = [];
        imageFetchers = [
          "Embedded Image Extractor"
          "Screen Grabber"
        ];
      };
    };
    books = {};
    homevideos = {
      Video = {
        metadataFetchers = [];
        imageFetchers = [
          "Embedded Image Extractor"
          "Screen Grabber"
        ];
        imageOptions = {};
      };
    };
    musicvideos = {
      MusicVideo = {
        metadataFetchers = [];
        imageFetchers = [
          "Embedded Image Extractor"
          "Screen Grabber"
        ];
      };
    };
    boxsets = {
      Movie = {
        metadataFetchers = [
          "TheMovieDb"
          "The Open Movie Database"
        ];
        imageFetchers = [
          "TheMovieDb"
          "The Open Movie Database"
          "Embedded Image Extractor"
          "Screen Grabber"
        ];
      };
      Series = {
        metadataFetchers = [
          "TheMovieDb"
          "The Open Movie Database"
        ];
        imageFetchers = ["TheMovieDb"];
      };
      Season = {
        metadataFetchers = ["TheMovieDb"];
        imageFetchers = ["TheMovieDb"];
      };
      Episode = {
        metadataFetchers = [
          "TheMovieDb"
          "The Open Movie Database"
        ];
        imageFetchers = [
          "TheMovieDb"
          "The Open Movie Database"
          "Embedded Image Extractor"
          "Screen Grabber"
        ];
      };
    };
  };
  libraryOpts = {name, ...}: {
    options = with lib; {
      enabled = mkOption {
        type = types.bool;
        default = true;
        description = "Whether or not this library is enabled";
      };
      contentType = mkOption {
        type = types.enum [
          "movies"
          "music"
          "tvshows"
          "books"
          "homevideos"
          "musicvideos"
          "boxsets"
        ];
        description = ''
          The type of content this library contains. Used for setting the default image/metadata fetchers.
        '';
      };
      enablePhotos = mkOption {
        type = types.bool;
        default = true;
        description = "Whether or not media in this library should display photos";
      };
      enableRealtimeMonitor = mkOption {
        type = types.bool;
        default = true;
        description = "Changes to files will be processed immediately on supported file systems";
      };
      enableLUFSScan = mkOption {
        type = types.bool;
        default = true;
        # TODO: Figure out what this option does
        # description = "";
      };
      enableChapterImageExtraction = mkOption {
        type = types.bool;
        default = false;
        description = "Whether or not to extract frames from the media to show as previews for chapters";
      };
      extractChapterImagesDuringLibraryScan = mkOption {
        type = types.bool;
        default = false;
        description = "Whether or not to extract frames for previews for chapters during library scans";
      };
      enableTrickplayImageExtraction = mkOption {
        type = types.bool;
        default = false;
        description = "Enables trickplay image generation for previews when skipping in media";
      };
      extractTrickplayImagesDuringLibraryScan = mkOption {
        type = types.bool;
        default = false;
        description = "Whether or not trickplay images should be extracted during the library scan";
      };
      saveTrickplayWithMedia = mkOption {
        type = types.bool;
        default = false;
        description = "Saving trickplay images into media folders will put them next to your media for easy migration and access";
      };
      saveLyricsWithMedia = mkOption {
        type = types.bool;
        default = false;
        description = "Saving lyrics into media folders will put them next to your media for easy migration and access";
      };
      pathInfos = mkOption {
        type = with types; listOf str;
        description = "List of paths for media in this library";
      };
      saveLocalMetadata = mkOption {
        type = types.bool;
        default = false;
        # TODO: Figure out what this option does
        # description = "";
      };
      enableAutomaticSeriesGrouping = mkOption {
        type = types.bool;
        default = false;
        description = "Series that are spread across multiple folders within this library will be automatically merged into a single series.";
      };
      enableEmbeddedTitles = mkOption {
        type = types.bool;
        default = false;
        description = "Whether or not to use the title embedded in the file if no internet metadata is available (if any is embedded)";
      };
      enableEmbeddedExtraTitles = mkOption {
        type = types.bool;
        default = false;
        description = "Use the episode information from the embedded metadata if available.";
      };
      enableEmbeddedEpisodeInfos = mkOption {
        type = types.bool;
        default = false;
        # TODO: Figure out what this does
        # description = "";
      };
      automaticRefreshIntervalDays = mkOption {
        type = types.int;
        default = 30;
        description = "How often to automatically refresh metadata from the internet. (in days)";
      };
      seasonZeroDisplayName = mkOption {
        type = types.str;
        default = "Specials";
        description = "What title should the 'specials' season (season 0) display?";
      };
      preferredMetadataLanguage = mkOption {
        type = types.str;
        default = "en";
        description = "What language should metadata be fetched for? Affects titles, descriptions, etc.";
      };
      metadataCountryCode = mkOption {
        type = types.str;
        default = "";
        # TODO: Figure out what this does
        # description = "idk";
      };
      metadataSavers = mkOption {
        type = with types; listOf str;
        default = [];
        description = "Pick the file formats to use when saving your metadata.";
        example = ["Nfo"];
      };
      disabledLocalMetadataReaders = mkOption {
        type = with types; listOf str;
        default = [];
        # TODO: find out what this does
        # description = "What title should the 'specials' season (season 0) display?";
      };
      localMetadataReaderOrder = mkOption {
        type = with types; listOf str;
        default = ["Nfo"];
        description = "What order should local metadata readers be prioritised";
      };
      disabledSubtitleFetchers = mkOption {
        type = with types; listOf str;
        default = [];
        description = "What order should local metadata readers be prioritised";
        example = ["Open Subtitles"];
      };
      subtitleFetcherOrder = mkOption {
        type = with types; listOf str;
        default = ["Open Subtitles"];
        description = "Enable and rank your preferred subtitle downloaders in order of priority.";
      };
      disabledMediaSegmentProviders = mkOption {
        type = with types; listOf str;
        default = [];
        # TODO: Find out what this does
        # description = "Enable and rank your preferred subtitle downloaders in order of priority.";
      };
      mediaSegmentProvideOrder = mkOption {
        type = with types; listOf str;
        default = [];
        # TODO: Find out what this does
        # description = "Enable and rank your preferred subtitle downloaders in order of priority.";
      };
      skipSubtitlesIfEmbeddedSubtitlesPresent = mkOption {
        type = types.bool;
        default = false;
        description = "Keeping text versions of subtitles will result in more efficient delivery and decrease the likelihood of video transcoding.";
      };
      skipSubtitlesIfAudioTrackMatches = mkOption {
        type = types.bool;
        default = false;
        description = "Uncheck this to ensure all videos have subtitles, regardless of audio language.";
      };
      subtitleDownloadLanguages = mkOption {
        type = with types; listOf str;
        default = ["eng"];
      };
      requirePerfectSubtitleMatch = mkOption {
        type = types.bool;
        default = true;
      };
      saveSubtitlesWithMedia = mkOption {
        type = types.bool;
        default = true;
        description = "Storing subtitles next to video files will allow them to be more easily managed.";
      };

      disabledLyricFetchers = mkOption {
        type = with types; listOf str;
        default = [];
      };
      lyricFetcherOrder = mkOption {
        type = with types; listOf str;
        default = [];
      };

      customTagDelimiters = mkOption {
        type = with types; listOf str;
        default = [
          "/"
          "|"
          ";"
          "\\"
        ];
      };
      delimiterWhitelist = mkOption {
        type = with types; listOf str;
        default = [];
      };
      automaticallyAddToCollection = mkOption {
        type = types.bool;
        default = false;
        description = "Toggles whether or not similar series/shows (ie. sequals or spinoffs) will be grouped in collections.";
      };
      allowEmbeddedSubtitles = mkOption {
        type = with types;
          enum [
            "AllowAll"
            "AllowText"
            "AllowImages"
            "AllowNone"
          ];
        default = "AllowAll";
        description = "Disable subtitles that are packaged within media containers. Requires a full library refresh.";
      };
      # NOTE: This is an abstraction of the file contents. It will need to be transformed
      # before use.
      typeOptions = mkOption {
        type = with types; attrsOf attrs;
        default = defaultTypeOptions.${cfg.libraries."${name}".contentType};
      };
    };
  };
in {
  options.services.declarative-jellyfin.libraries = mkOption {
    description = "Library configuration";
    default = {};
    type = with types; attrsOf (submodule libraryOpts);
    example = {
      "Anime" = {
        enabled = true;
        contentType = "boxsets";
        enableTrickplayImageExtraction = true;
        typeOptions.series.metadataFetchers = [
          "TheTVDB"
          "TheMovieDb"
          "AniList"
        ];
      };
    };
  };
}
